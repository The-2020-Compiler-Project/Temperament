# 第一阶段报告

## 1、进展

### （1）整体讨论

第一次上机我们组内对文法进行确定，考虑到组内成员基础和能力的不同，课设难度较大，我们采用简单编译实例文档中给出的文法，即只包括变量声明语句、赋值语句以及算术表达式。数据类型有integer、real和char，操作符有"+"、"-"、"*"、"/"。先用简单文法设计出编译器前端、后端，作为保底，完成后大家也对整体设计有了更深入的了解，方便后续增加文法内容。

确定文法后我们再明确分工，其中依扎提同学负责词法分析部分；陈桠楠同学负责语法分析部分；张嘉琦同学负责符号表部分；蔡铭修同学负责中间代码生成部分；我负责的是中间代码优化和目标代码生成部分。

整体的流程：词法分析-->语法分析-->符号表生成-->中间代码生成-->中间代码优化-->目标代码生成

### （2）个人进展

对于中间代码优化这一部分，我对算法实现并没有很好的想法，对于优化过程了解也不深入。因此，在写代码前，我先学习了这部分内容，算法思路如下：

基本块划分-->对每个模块构建DAG进行优化-->生成优化后的四元式

其中基本块划分前，需要中间代码生成阶段得到的四元式，对于这部分的衔接，我目前是采用了文件I/O的方式，这样两部分之间较为独立，调试也比较方便。



① 基本块划分部分，由于现在的文法较为简单，不会出现多个基本块的情况，该过程跳过。计划后期添加if-else语句和while循环语句，故设计数据结构时预先设置了基本块标识，构建DAG函数部分也是多基本块的情况。四元式及DAG数据结构如下：

```c++
struct token
{
    string name;
    int type;        //2为临时变量，3为数字，1为非临时变量
    bool operator == (const token& t) const       //list remove函数判断是否相等
    {
        return (name == t.name && type == t.type);
    }
};

struct Quatemion        //四元式结构体
{
    int block=1;        //基本块标识
    int type=-1;        //类型 0 1 2 3
    string op=" ";      //操作
    token num1;         //操作数1
    token num2;         //操作数2
    token ans;          //结果
};

struct Quatemion qua[200];  //四元式数组

struct Node             //DAG节点
{
    int left=-1;           //左子节点标识，-1代表为空
    int right=-1;          //右子节点标识，-1代表为空
    string op=" ";         //操作
    token m_sign;          //主标记
    list<token> sign;      //附加标记
};

struct DAG
{
    int num = 0;
    Node node[200];
};

struct DAG dag;
```

对于节点附加标记我是采用了list类型，这样方便插入、删除操作。DAG是由节点数组构成，遍历较为方便。



② 构建DAG部分的思路如下：

A:=B类型。先查找DAG表里是否有节点A且在附加标记上，若有则要将其从附加标记中删除，然后判断节点B是否存在，若存在直接将A附加到B之上并判断优先级来决定是否需要调整位置，如果节点B不存在则先添加节点B再执行附加过程

+，-，*，/类型的四元式 (op,B,C,A)。先判断B，C节点是否存在，不存在则建立。判断B，C是不是同时为常数类型，若是则先计算出常数运算结果p，p不存在则建立，判断A是否已在附加标记中，是则删去，然后将A添加到p的附加标记。若B,C不同时为常数类型的，判断A是否已在附加标记中，是则删去；再遍历整个DAG表看是否有一个节点它的操作符是op，左右节点是B和C，如(op,B,C,D)如果有则把A附加在D之上并判断是否需要调整A和D的顺序；否则另定义节点A，将节点B、C标号赋给A的左右节点。



③ 根据DAG生成优化后的四元式部分的思路如下：

遍历DAG图的每个节点，如果该节点有附标记则遍历其附加标记，若某个附加标记是非临时变量则将生成(:=,B,_,A)四元式。如果该节点非叶节点说明他有左右孩子，则根据该节点的操作符来生成对应的(op,B,C,A)四元式。



 测试结果

① 

样例数据 (:=,2,_,a)，(*,2,5,t1)，(+,t1,a,t2)，(:=,t2, _ ,b)

样例结果 (:=,2 , _ ,a)，(+,10,a,t2)，(:=,t2, _ ,b)

测试结果(:=,2, _ ,a)，(+,10,2,b)

从结果看测试的优化程度高于样例优化，但也暴露出问题，上面优化后的四元式还可以再优化。目前对于这个问题，我的想法是多次优化，直到这次生成的四元式序列和上次没有变化，暂未代码实现

②

测试数据  ( * , 2 , 5 , t1 )，( := , t1 , _ , a )，( + , a , b , t2 )，( := , t2 , _ , a )

​                  ( + , a , b , t3 )，( / , t3 , 2 , t4 )，( * , t4 , 5 , t5 )，( := , t5 , _ , b )			

测试结果  ( + , 10 , b , a )， ( + , a , b , t3 )，( / , t3 , 2 , t4 )，( * , t4 , 5 , b )

## 2、问题

设计过程中困难部分还是前期的算法思路，对此我也查阅了很多资料、请教了学长和老师，综合起来确定优化思路。编写代码过程中发现了许多冗余的部分，然后做了删除简化的工作。编译通过后进行测试，发现了几个问题并进行了修改。

① 对于一个四元式中的操作数（假设为B,C）和结果（假设为A），需要先查找DAG中是否有B,C节点存在，不存在则新建。这样类似查找节点是否存在的我刚开始只在DAG中去对比节点的主标记，忽略了附加标记，导致优化结果不正确。后加上遍历DAG附加标记的部分。

② 修改以上错误后，运行过程中出现错误，显示List使用时出现读取访问权限冲突的问题，对此我上网查询无果，多次调试最后也没发现语法、逻辑上的错误，最终调整几个语句顺序解除报错，但我还是不理解为何出错。

③ 刚开始测试时，我将读取每个四元式后的节点数量输出，发现每次比预想的多生成几个节点。然后我在代码中生成节点的部分进行查错。发现一处生成节点部分放在了遍历节点的循环中，对此进行改正。

## 3、下一步工作

中间代码优化部分整体上已完成，后期需添加基本块划分函数。该模块还需进一步完善，如考虑"+"、"*"的交换性等。下一步工作主要集中在目标代码生成模块。中间代码优化模块的编写让我深刻认识到“凡是预则立，不预则废”的道理。所以先还是对这部分进行学习准备，先设计好大概的思路，再细致设计每一步，最后编写代码、测试。

其它的工作就是去于组员交流，了解她们现在的进度，指出可能需要规范统一的部分，便于后期代码合并。